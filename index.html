<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Thief in the Cyber World</title>
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Orbitron', sans-serif;
            color: #0ff;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        canvas {
            background: #050510;
            border: 1px solid #0ff;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 6;
        }

        .hud-bar {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-box {
            background: rgba(0, 10, 20, 0.9);
            padding: 10px 20px;
            border: 1px solid #0ff;
            border-bottom: 3px solid #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            text-shadow: 0 0 5px #0ff;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 40px; /* Slightly smaller to fit mobile better */
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            text-align: center;
            padding: 0 20px;
            line-height: 1.2;
        }

        p {
            font-size: 16px;
            margin-bottom: 30px;
            color: #ddd;
            text-align: center;
            max-width: 500px;
            padding: 0 20px;
            line-height: 1.5;
        }

        .btn {
            background: rgba(0, 255, 255, 0.15);
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            font-weight: bold;
            padding: 15px 50px;
            border: 1px solid #0ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            pointer-events: auto;
            border-radius: 2px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 25px #0ff;
        }
        
        #player-id-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-size: 12px;
            opacity: 0.7;
            text-shadow: 0 0 5px #0ff;
        }

        /* Controls */
        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 160px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        #joystick-zone {
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: none; 
            pointer-events: auto;
            touch-action: none;
            position: relative;
        }

        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #0ff;
        }

        #fire-btn {
            width: 100px;
            height: 100px;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff3232;
            border-radius: 50%;
            display: none;
            pointer-events: auto;
            align-self: flex-end;
            margin-bottom: 20px;
            color: #ff3232;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 0 15px rgba(255, 50, 50, 0.3);
            transition: all 0.1s;
        }

        #fire-btn:active {
            background: rgba(255, 50, 50, 0.6);
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        .shake {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="scanlines"></div>
    <div id="player-id-display"></div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-bar">
            <div class="stat-box">CREDITS: $<span id="scoreDisplay">0</span> / $100</div>
            <div class="stat-box">TIME: <span id="timeDisplay">2:00</span></div>
        </div>
        
        <div id="controls-container">
            <div id="joystick-zone">
                <div id="joystick-knob"></div>
            </div>
            <div id="fire-btn" style="display:none;">FIRE</div>
        </div>
    </div>

    <div id="message-overlay">
        <h1 id="overlay-title">THIEF IN THE CYBER WORLD</h1>
        <p id="overlay-desc">
            <strong>MISSION:</strong> Steal $100 and escape.<br>
            <strong>INTEL:</strong> Avoid mines. Destroy drones.<br>
            <span style="color:#0ff">PC:</span> WASD + Space to Shoot.<br>
            <span style="color:#0ff">Mobile:</span> Joystick + Fire Button.
        </p>
        <button class="btn" id="start-btn">JACK IN</button>
    </div>
</div>

<script>
    // --- TELEGRAM INIT ---
    let tgUser = null;
    if (window.Telegram && window.Telegram.WebApp) {
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
        tgUser = window.Telegram.WebApp.initDataUnsafe?.user;
        
        if (tgUser) {
            document.getElementById('player-id-display').textContent = `OPERATOR: ${tgUser.username || tgUser.first_name} [ID:${tgUser.id}]`;
        }
    }

    // --- Configuration ---
    const TARGET_SCORE = 100;
    const TIME_LIMIT_SECONDS = 120;
    const ACCELERATION = 2000;
    const MAX_SPEED = 450;
    const FRICTION = 0.92;
    
    const COLORS = {
        player: '#0ff',
        playerTrail: 'rgba(0, 255, 255, 0.4)',
        coin: '#ffd700',
        obstacle: '#ff3a3a', 
        seeker: '#ff00aa',
        projectile: '#eeffff',
        street: '#0a0a12',
        building: '#11111a',
        buildingTop: '#151522'
    };

    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    
    // Elements
    const scoreDisplay = document.getElementById('scoreDisplay');
    const timeDisplay = document.getElementById('timeDisplay');
    const overlay = document.getElementById('message-overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlayDesc = document.getElementById('overlay-desc');
    const startBtn = document.getElementById('start-btn');
    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    const fireBtn = document.getElementById('fire-btn');

    // Pre-rendered City Background
    let cityCanvas = document.createElement('canvas');
    let cityCtx = cityCanvas.getContext('2d');
    const CITY_SIZE = 2000;

    let gameState = 'START'; 
    let lastTime = 0;
    let timer = TIME_LIMIT_SECONDS;
    let score = 0;
    
    // Player
    const player = {
        x: 0,
        y: 0,
        vx: 0, 
        vy: 0,
        size: 24,
        trail: [],
        rotation: 0,
        cooldown: 0,
        invulnerable: 0
    };

    // Entities
    let coins = [];
    let obstacles = [];
    let seekers = []; 
    let particles = [];
    let projectiles = [];
    
    // Inputs
    const keys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        w: false, s: false, a: false, d: false,
        ' ': false 
    };

    const joystick = {
        active: false,
        originX: 0, originY: 0,
        currentX: 0, currentY: 0,
        radius: 50,
        inputX: 0, inputY: 0
    };

    // --- Initialization ---

    function generateCityBackground() {
        cityCanvas.width = CITY_SIZE;
        cityCanvas.height = CITY_SIZE;
        
        cityCtx.fillStyle = '#08080c';
        cityCtx.fillRect(0, 0, CITY_SIZE, CITY_SIZE);

        const blockSize = 250;
        const streetWidth = 50;

        cityCtx.fillStyle = '#15151a'; 
        for(let y=0; y<CITY_SIZE; y+=blockSize) {
            cityCtx.fillRect(0, y, CITY_SIZE, streetWidth);
            cityCtx.fillStyle = '#2a2a35';
            for(let i=0; i<CITY_SIZE; i+=40) cityCtx.fillRect(i, y + streetWidth/2 - 2, 20, 4);
            cityCtx.fillStyle = '#15151a'; 
        }
        for(let x=0; x<CITY_SIZE; x+=blockSize) {
            cityCtx.fillRect(x, 0, streetWidth, CITY_SIZE);
            cityCtx.fillStyle = '#2a2a35';
            for(let i=0; i<CITY_SIZE; i+=40) cityCtx.fillRect(x + streetWidth/2 - 2, i, 4, 20);
            cityCtx.fillStyle = '#15151a'; 
        }

        for(let x=0; x<CITY_SIZE; x+=blockSize) {
            for(let y=0; y<CITY_SIZE; y+=blockSize) {
                const bx = x + streetWidth;
                const by = y + streetWidth;
                const bw = blockSize - streetWidth;
                const bh = blockSize - streetWidth;
                
                if (Math.random() > 0.05) { 
                    cityCtx.fillStyle = '#0f1218';
                    cityCtx.fillRect(bx + 5, by + 5, bw - 10, bh - 10);
                    cityCtx.fillStyle = '#161922';
                    cityCtx.fillRect(bx + 15, by + 15, bw - 30, bh - 30);
                    cityCtx.fillStyle = '#222530';
                    cityCtx.fillRect(bx + 30, by + 30, 20, 20);
                    cityCtx.fillRect(bx + bw - 50, by + bh - 50, 30, 15);

                    const lightColor = Math.random() > 0.5 ? '#003333' : '#330033';
                    cityCtx.fillStyle = lightColor;
                    cityCtx.beginPath();
                    cityCtx.arc(bx + 20, by + 20, 3, 0, Math.PI*2);
                    cityCtx.fill();
                }
            }
        }
        
        for(let x=0; x<CITY_SIZE; x+=blockSize) {
            for(let y=0; y<CITY_SIZE; y+=blockSize) {
                const grad = cityCtx.createRadialGradient(x+streetWidth/2, y+streetWidth/2, 0, x+streetWidth/2, y+streetWidth/2, 40);
                grad.addColorStop(0, 'rgba(255, 200, 100, 0.1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                cityCtx.fillStyle = grad;
                cityCtx.fillRect(x, y, streetWidth, streetWidth);
            }
        }
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    window.addEventListener('resize', resize);
    generateCityBackground();
    resize();

    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouch) {
        joystickZone.style.display = 'block';
        fireBtn.style.display = 'flex';
    }

    // --- Input Handling ---

    window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
    window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        const rect = joystickZone.getBoundingClientRect();
        joystick.active = true;
        joystick.originX = rect.left + rect.width / 2;
        joystick.originY = rect.top + rect.height / 2;
        updateJoystick(touch.clientX, touch.clientY);
    });

    joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystick.active) return;
        const touch = e.changedTouches[0];
        updateJoystick(touch.clientX, touch.clientY);
    });

    const endJoystick = (e) => {
        e.preventDefault();
        joystick.active = false;
        joystick.inputX = 0;
        joystick.inputY = 0;
        joystickKnob.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
    };

    joystickZone.addEventListener('touchend', endJoystick);
    joystickZone.addEventListener('touchcancel', endJoystick);

    function updateJoystick(clientX, clientY) {
        const dx = clientX - joystick.originX;
        const dy = clientY - joystick.originY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let moveX = dx, moveY = dy;
        if (dist > joystick.radius) {
            const angle = Math.atan2(dy, dx);
            moveX = Math.cos(angle) * joystick.radius;
            moveY = Math.sin(angle) * joystick.radius;
        }
        joystickKnob.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;
        joystick.inputX = moveX / joystick.radius;
        joystick.inputY = moveY / joystick.radius;
    }

    fireBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        attemptShoot();
    });

    // --- Game Logic ---

    function attemptShoot() {
        if (player.cooldown > 0) return;
        
        player.cooldown = 0.25; 

        // Use current velocity for shoot direction
        let speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        let dirX = 1, dirY = 0;
        
        if (speed > 10) {
            dirX = player.vx / speed;
            dirY = player.vy / speed;
        } else {
            // If standing still, use rotation
            dirX = Math.cos(player.rotation);
            dirY = Math.sin(player.rotation);
        }

        projectiles.push({
            x: player.x,
            y: player.y,
            vx: dirX * 900 + player.vx * 0.2, 
            vy: dirY * 900 + player.vy * 0.2,
            life: 0.8
        });

        if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.HapticFeedback) {
            window.Telegram.WebApp.HapticFeedback.selectionChanged();
        }
    }

    function spawnCoin() {
        const margin = 50;
        const coin = {
            x: margin + Math.random() * (canvas.width - margin * 2),
            y: margin + Math.random() * (canvas.height - margin * 2),
            radius: 9,
            // CHANGED: Base value $2, Bonus value $8 (previously $1/$5)
            value: Math.random() > 0.8 ? 8 : 2, 
            floatOffset: Math.random() * Math.PI * 2,
            pulse: 0
        };
        coins.push(coin);
    }

    function spawnSeeker() {
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        if (edge === 0) { x = Math.random() * canvas.width; y = -50; }
        else if (edge === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
        else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
        else { x = -50; y = Math.random() * canvas.height; }

        seekers.push({
            x: x,
            y: y,
            radius: 16,
            speed: 120 + Math.random() * 50, 
            angle: 0,
            rotorAngle: 0
        });
    }

    function spawnObstacle() {
        const margin = 50;
        let x, y, dist;
        do {
            x = margin + Math.random() * (canvas.width - margin * 2);
            y = margin + Math.random() * (canvas.height - margin * 2);
            dist = Math.hypot(x - player.x, y - player.y);
        } while(dist < 200);

        const obstacle = {
            x: x,
            y: y,
            radius: 18 + Math.random() * 10,
            angle: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 2,
            speed: 60 + Math.random() * 60,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2
        };
        obstacles.push(obstacle);
    }

    function resetGame() {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.vx = 0;
        player.vy = 0;
        player.trail = [];
        player.cooldown = 0;
        player.invulnerable = 0;
        score = 0;
        timer = TIME_LIMIT_SECONDS;
        coins = [];
        obstacles = [];
        seekers = [];
        particles = [];
        projectiles = [];
        
        scoreDisplay.textContent = score;
        updateTimerDisplay();

        for(let i=0; i<6; i++) spawnCoin();
        for(let i=0; i<6; i++) spawnObstacle(); // Reduced start obstacles slightly
        
        gameState = 'PLAYING';
        overlay.classList.add('hidden');
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function updateTimerDisplay() {
        const m = Math.floor(timer / 60);
        const s = Math.floor(timer % 60).toString().padStart(2, '0');
        timeDisplay.textContent = `${m}:${s}`;
        
        if (timer <= 30) timeDisplay.style.color = '#f03e3e';
        else timeDisplay.style.color = '#0ff';
    }

    function createExplosion(x, y, color, count) {
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * 150;
            particles.push({
                x: x, y: y,
                vx: Math.cos(angle) * velocity,
                vy: Math.sin(angle) * velocity,
                life: 1.0, color: color,
                size: Math.random() * 3 + 1
            });
        }
    }

    function triggerShake() {
        gameContainer.classList.remove('shake');
        void gameContainer.offsetWidth; 
        gameContainer.classList.add('shake');
    }

    function gameOver(won) {
        gameState = won ? 'WON' : 'GAME_OVER';
        overlay.classList.remove('hidden');
        
        if (won) {
            overlayTitle.textContent = "HEIST SUCCESSFUL";
            overlayTitle.style.color = "#0f0";
            overlayDesc.innerHTML = `You secured <strong>$${score}</strong> and escaped.<br>Time remaining: ${Math.floor(timer)}s.`;
            startBtn.textContent = "STEAL AGAIN";
        } else {
            overlayTitle.textContent = "BUSTED";
            overlayTitle.style.color = "#f03e3e";
            overlayDesc.innerHTML = `Connection terminated.<br>Credits Stolen: $${score} / $${TARGET_SCORE}`;
            startBtn.textContent = "RETRY";
        }

        if (tgUser) {
            if (window.Telegram.WebApp.HapticFeedback) {
                 window.Telegram.WebApp.HapticFeedback.notificationOccurred(won ? 'success' : 'error');
            }

            const payload = {
                userId: tgUser.id,
                username: tgUser.username || tgUser.first_name,
                score: score,
                timeLeft: Math.floor(timer),
                won: won
            };

            fetch('/api/submit-score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).catch(console.error);
        }
    }

    function update(dt) {
        if (gameState !== 'PLAYING') return;

        timer -= dt;
        if (timer <= 0) {
            timer = 0;
            gameOver(false);
            return;
        }
        updateTimerDisplay();
        
        if (player.cooldown > 0) player.cooldown -= dt;
        if (player.invulnerable > 0) player.invulnerable -= dt;

        // --- Physics Based Movement ---
        let inputX = 0;
        let inputY = 0;

        if (joystick.active || Math.abs(joystick.inputX) > 0.1 || Math.abs(joystick.inputY) > 0.1) {
            inputX = joystick.inputX;
            inputY = joystick.inputY;
        } else {
            if (keys.ArrowUp || keys.w) inputY = -1;
            if (keys.ArrowDown || keys.s) inputY = 1;
            if (keys.ArrowLeft || keys.a) inputX = -1;
            if (keys.ArrowRight || keys.d) inputX = 1;
            
            if (inputX !== 0 || inputY !== 0) {
                const len = Math.sqrt(inputX*inputX + inputY*inputY);
                inputX /= len;
                inputY /= len;
            }
        }

        player.vx += inputX * ACCELERATION * dt;
        player.vy += inputY * ACCELERATION * dt;

        player.vx *= Math.pow(FRICTION, dt * 60);
        player.vy *= Math.pow(FRICTION, dt * 60);

        const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > MAX_SPEED) {
            player.vx = (player.vx / speed) * MAX_SPEED;
            player.vy = (player.vy / speed) * MAX_SPEED;
        }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        
        if (speed > 10) {
            player.rotation = Math.atan2(player.vy, player.vx);
        }

        if (keys[' ']) attemptShoot();

        const margin = player.size / 2;
        if (player.x < margin) { player.x = margin; player.vx *= -0.5; }
        if (player.x > canvas.width - margin) { player.x = canvas.width - margin; player.vx *= -0.5; }
        if (player.y < margin) { player.y = margin; player.vy *= -0.5; }
        if (player.y > canvas.height - margin) { player.y = canvas.height - margin; player.vy *= -0.5; }

        player.trail.push({x: player.x, y: player.y});
        if (player.trail.length > 10) player.trail.shift();

        // --- Spawners ---
        if (coins.length < 8) { if (Math.random() < 0.08) spawnCoin(); }
        
        const difficulty = 1 + (score / 150); 
        
        // CHANGED: Obstacles cap reduced to 6 base + scale, slightly easier
        const maxObstacles = 6 + Math.floor(score / 20);
        if (obstacles.length < maxObstacles) { if (Math.random() < 0.03) spawnObstacle(); }

        // CHANGED: Seekers appear later ($25) and scale slower (div 30)
        const maxSeekers = Math.floor((score - 25) / 30); 
        if (score >= 25 && seekers.length < maxSeekers) {
             if (Math.random() < 0.01) spawnSeeker();
        }

        // --- Entity Updates ---
        
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            
            if (p.life <= 0 || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                projectiles.splice(i, 1);
                continue;
            }

            let hit = false;
            for (let j = seekers.length - 1; j >= 0; j--) {
                const s = seekers[j];
                const dist = Math.hypot(p.x - s.x, p.y - s.y);
                if (dist < s.radius + 5) {
                    createExplosion(s.x, s.y, '#f0f', 15);
                    if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.HapticFeedback) {
                        window.Telegram.WebApp.HapticFeedback.impactOccurred('medium');
                    }
                    score += 2; 
                    scoreDisplay.textContent = score;
                    seekers.splice(j, 1);
                    hit = true;
                    break; 
                }
            }
            if (hit) {
                projectiles.splice(i, 1);
                continue;
            }

            for (let k = obstacles.length - 1; k >= 0; k--) {
                const o = obstacles[k];
                const dist = Math.hypot(p.x - o.x, p.y - o.y);
                if (dist < o.radius + 5) {
                    createExplosion(o.x, o.y, '#ff3a3a', 10);
                     if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.HapticFeedback) {
                        window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
                    }
                    obstacles.splice(k, 1);
                    hit = true;
                    break;
                }
            }
            if (hit) projectiles.splice(i, 1);
        }

        obstacles.forEach(obs => {
            obs.x += obs.vx * obs.speed * difficulty * dt;
            obs.y += obs.vy * obs.speed * difficulty * dt;
            obs.angle += obs.rotationSpeed * dt;

            if (obs.x < 0 || obs.x > canvas.width) obs.vx *= -1;
            if (obs.y < 0 || obs.y > canvas.height) obs.vy *= -1;

            if (player.invulnerable <= 0) {
                const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
                if (dist < player.size/2 + obs.radius - 2) {
                    if (score > 0) {
                        score = Math.max(0, score - 5); 
                        scoreDisplay.textContent = score;
                        createExplosion(player.x, player.y, COLORS.player, 12);
                        triggerShake();
                        
                        if (window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.impactOccurred('medium');

                        const angle = Math.atan2(player.y - obs.y, player.x - obs.x);
                        player.vx += Math.cos(angle) * 600;
                        player.vy += Math.sin(angle) * 600;
                        
                        timer = Math.max(0, timer - 3); 
                        player.invulnerable = 1.0; 
                    }
                }
            }
        });

        seekers.forEach(seeker => {
            const angle = Math.atan2(player.y - seeker.y, player.x - seeker.x);
            const currentSpeed = seeker.speed * (1 + score/200);
            
            seeker.x += Math.cos(angle) * currentSpeed * dt;
            seeker.y += Math.sin(angle) * currentSpeed * dt;
            seeker.angle = angle;
            seeker.rotorAngle += dt * 25; 

            if (player.invulnerable <= 0) {
                const dist = Math.hypot(player.x - seeker.x, player.y - seeker.y);
                if (dist < player.size/2 + seeker.radius) {
                    score = Math.max(0, score - 10);
                    scoreDisplay.textContent = score;
                    triggerShake();
                    createExplosion(player.x, player.y, '#d0f', 20);
                    
                    if (window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.impactOccurred('heavy');

                    seeker.x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                    seeker.y = Math.random() > 0.5 ? -50 : canvas.height + 50;
                    
                    player.invulnerable = 1.0;
                }
            }
        });

        for (let i = coins.length - 1; i >= 0; i--) {
            const coin = coins[i];
            coin.pulse += dt * 4;
            
            const dist = Math.hypot(player.x - coin.x, player.y - coin.y);
            if (dist < player.size/2 + coin.radius + 10) {
                score += coin.value;
                scoreDisplay.textContent = score;
                createExplosion(coin.x, coin.y, COLORS.coin, 6);
                if (window.Telegram.WebApp.HapticFeedback) window.Telegram.WebApp.HapticFeedback.selectionChanged();

                coins.splice(i, 1);
                
                if (score >= TARGET_SCORE) gameOver(true);
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt * 2;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        const bgX = -(player.x * 0.4) % CITY_SIZE;
        const bgY = -(player.y * 0.4) % CITY_SIZE;

        ctx.drawImage(cityCanvas, bgX, bgY);
        ctx.drawImage(cityCanvas, bgX + CITY_SIZE, bgY);
        ctx.drawImage(cityCanvas, bgX, bgY + CITY_SIZE);
        ctx.drawImage(cityCanvas, bgX + CITY_SIZE, bgY + CITY_SIZE);

        const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.height/3, canvas.width/2, canvas.height/2, canvas.height);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.7)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,canvas.width, canvas.height);

        ctx.strokeStyle = '#eeffff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#0ff';
        ctx.lineWidth = 3;
        projectiles.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - p.vx * 0.02, p.y - p.vy * 0.02); 
            ctx.stroke();
        });
        ctx.shadowBlur = 0;

        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        if (player.trail.length > 1) {
            ctx.strokeStyle = COLORS.playerTrail;
            ctx.lineWidth = player.size / 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(player.trail[0].x, player.trail[0].y);
            for(let i=1; i<player.trail.length; i++) ctx.lineTo(player.trail[i].x, player.trail[i].y);
            ctx.stroke();
        }

        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.rotation);

        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS.player;
        ctx.fillStyle = '#000';
        ctx.strokeStyle = COLORS.player;
        
        if (player.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
             ctx.strokeStyle = 'transparent'; 
        }

        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(14, 0); ctx.lineTo(-10, 10); ctx.lineTo(-6, 0); ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        if (Math.abs(player.vx) > 10 || Math.abs(player.vy) > 10) {
            ctx.fillStyle = '#0ff';
            ctx.globalAlpha = 0.6 + Math.random() * 0.4;
            ctx.beginPath();
            ctx.moveTo(-10, -5);
            ctx.lineTo(-20 - Math.random()*10, 0);
            ctx.lineTo(-10, 5);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        ctx.restore();

        coins.forEach(coin => {
            const scale = 1 + Math.sin(coin.pulse) * 0.1;
            ctx.save();
            ctx.translate(coin.x, coin.y);
            ctx.scale(scale, scale);
            ctx.shadowBlur = 10; ctx.shadowColor = COLORS.coin;
            ctx.fillStyle = coin.value > 5 ? '#ffd700' : '#dcb158';
            ctx.beginPath();
            ctx.arc(0, 0, coin.radius, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            // CHANGED: Update text to reflect new value
            ctx.fillText(coin.value > 5 ? '$8' : '$2', 0, 1);
            ctx.restore();
        });

        obstacles.forEach(obs => {
            ctx.save();
            ctx.translate(obs.x, obs.y);
            ctx.rotate(obs.angle);
            ctx.shadowBlur = 8; ctx.shadowColor = COLORS.obstacle;
            ctx.fillStyle = '#300';
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, obs.radius * 0.6, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            for(let i=0; i<8; i++) {
                ctx.beginPath();
                ctx.rotate(Math.PI/4);
                ctx.moveTo(obs.radius * 0.6, 0);
                ctx.lineTo(obs.radius, 0);
                ctx.stroke();
            }
            ctx.restore();
        });

        seekers.forEach(seeker => {
            ctx.save();
            ctx.translate(seeker.x, seeker.y);
            ctx.rotate(seeker.angle + Math.PI/2);
            
            ctx.shadowBlur = 10; ctx.shadowColor = '#d0f';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-12, -12); ctx.lineTo(12, 12);
            ctx.moveTo(12, -12); ctx.lineTo(-12, 12);
            ctx.stroke();

            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = '#f0f';
            ctx.beginPath();
            ctx.arc(0, -2, 2, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = 'rgba(200, 255, 255, 0.5)';
            const rSize = 6;
            const offsets = [[-12, -12], [12, -12], [-12, 12], [12, 12]];
            
            offsets.forEach(pos => {
                ctx.beginPath();
                ctx.save();
                ctx.translate(pos[0], pos[1]);
                ctx.rotate(seeker.rotorAngle);
                ctx.ellipse(0, 0, rSize, 2, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            });

            ctx.restore();
        });
    }

    function gameLoop(timestamp) {
        if (gameState !== 'PLAYING') return;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
    }

    startBtn.addEventListener('click', () => {
        resetGame();
    });

    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

</script>
</body>
</html>
